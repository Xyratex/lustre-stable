diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/block/blk-lib.c linux-2.6.32-431.29.2.el6.x86_64/block/blk-lib.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/block/blk-lib.c	2014-07-28 03:21:52.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/block/blk-lib.c	2014-08-29 20:52:51.664000942 +0800
@@ -7,6 +7,7 @@
 #include <linux/blkdev.h>
 #include <linux/scatterlist.h>
 #include <linux/gfp.h>
+#include <linux/dss_types.h>
 
 #include "blk.h"
 
@@ -196,3 +197,58 @@
 	return ret;
 }
 EXPORT_SYMBOL(blkdev_issue_zeroout);
+
+int blkdev_issue_zeroout_dss(struct block_device *bdev, sector_t sector,
+			     sector_t nr_sects, gfp_t gfp_mask,
+			     unsigned char class)
+{
+	int ret;
+	struct bio *bio;
+	struct bio_batch bb;
+	unsigned int sz;
+	DECLARE_COMPLETION_ONSTACK(wait);
+
+	atomic_set(&bb.done, 1);
+	bb.flags = 1 << BIO_UPTODATE;
+	bb.wait = &wait;
+
+	ret = 0;
+	while (nr_sects != 0) {
+		bio = bio_alloc(gfp_mask,
+				min(nr_sects, (sector_t)BIO_MAX_PAGES));
+		if (!bio) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		bio->bi_sector = sector;
+		bio->bi_bdev   = bdev;
+		bio->bi_end_io = bio_batch_end_io;
+		bio->bi_private = &bb;
+
+		dss_set_bio_class(bio, class);
+
+		while (nr_sects != 0) {
+			sz = min((sector_t) PAGE_SIZE >> 9 , nr_sects);
+			ret = bio_add_page(bio, ZERO_PAGE(0), sz << 9, 0);
+			nr_sects -= ret >> 9;
+			sector += ret >> 9;
+			if (ret < (sz << 9))
+				break;
+		}
+		ret = 0;
+		atomic_inc(&bb.done);
+		submit_bio(WRITE, bio);
+	}
+
+	/* Wait for bios in-flight */
+	if (!atomic_dec_and_test(&bb.done))
+		wait_for_completion(&wait);
+
+	if (!test_bit(BIO_UPTODATE, &bb.flags))
+		/* One of bios in the batch was completed with error.*/
+		ret = -EIO;
+
+	return ret;
+}
+EXPORT_SYMBOL(blkdev_issue_zeroout_dss);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/block/blk-merge.c linux-2.6.32-431.29.2.el6.x86_64/block/blk-merge.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/block/blk-merge.c	2014-07-28 03:21:52.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/block/blk-merge.c	2014-08-29 20:52:51.664000942 +0800
@@ -6,6 +6,7 @@
 #include <linux/bio.h>
 #include <linux/blkdev.h>
 #include <linux/scatterlist.h>
+#include <linux/dss_types.h>
 
 #include "blk.h"
 
@@ -224,6 +225,13 @@
 int ll_back_merge_fn(struct request_queue *q, struct request *req,
 		     struct bio *bio)
 {
+	/* DSS.0 */
+	if (bio && req->bio) {
+		if ((DSS_BIO_CLASS(bio) || DSS_BIO_CLASS(req->bio)) &&
+		    (DSS_BIO_CLASS(bio) != DSS_BIO_CLASS(req->bio)))
+			return 0;
+	}
+
 	if (blk_rq_sectors(req) + bio_sectors(bio) >
 	    blk_rq_get_max_sectors(req)) {
 		req->cmd_flags |= REQ_NOMERGE;
@@ -242,6 +250,13 @@
 int ll_front_merge_fn(struct request_queue *q, struct request *req,
 		      struct bio *bio)
 {
+	/* DSS.1 */
+	if (bio && req->bio) {
+		if ((DSS_BIO_CLASS(bio) || DSS_BIO_CLASS(req->bio)) &&
+		    (DSS_BIO_CLASS(bio) != DSS_BIO_CLASS(req->bio)))
+			return 0;
+	}
+
 	if (blk_rq_sectors(req) + bio_sectors(bio) >
 	    blk_rq_get_max_sectors(req)) {
 		req->cmd_flags |= REQ_NOMERGE;
@@ -264,6 +279,13 @@
 	unsigned int seg_size =
 		req->biotail->bi_seg_back_size + next->bio->bi_seg_front_size;
 
+	/* DSS.2 */
+	if (next->bio && req->bio) {
+		if ((DSS_BIO_CLASS(next->bio) || DSS_BIO_CLASS(req->bio)) &&
+		    (DSS_BIO_CLASS(next->bio) != DSS_BIO_CLASS(req->bio)))
+			return 0;
+	}
+
 	/*
 	 * First check if the either of the requests are re-queued
 	 * requests.  Can't merge them if they are.
@@ -350,6 +372,13 @@
 	if (!rq_mergeable(req) || !rq_mergeable(next))
 		return 0;
 
+	/* DSS.3 */
+	if (next->bio && req->bio) {
+		if ((DSS_BIO_CLASS(next->bio) || DSS_BIO_CLASS(req->bio)) &&
+		    (DSS_BIO_CLASS(next->bio) != DSS_BIO_CLASS(req->bio)))
+			return 0;
+	}
+
 	/*
 	 * Don't merge file system requests and discard requests
 	 */
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/drivers/scsi/sd.c linux-2.6.32-431.29.2.el6.x86_64/drivers/scsi/sd.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/drivers/scsi/sd.c	2014-07-28 03:22:04.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/drivers/scsi/sd.c	2014-08-29 20:52:51.665000881 +0800
@@ -49,6 +49,7 @@
 #include <linux/mutex.h>
 #include <linux/string_helpers.h>
 #include <linux/async.h>
+#include <linux/dss_types.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
 
@@ -969,6 +970,44 @@
 	 * This indicates that the command is ready from our end to be
 	 * queued.
 	 */
+	/* Begin DSS.0 */
+	{
+		static int flag[8] = {0,0,0,0,0,0,0,0};
+		int classify = 0;
+		int which = 0;
+
+		if (!strncmp(SCpnt->device->model, "iSCSI Reference", 15)) {
+			which = 0;
+			classify = 1;
+		} else if (!strncmp(SCpnt->device->model, "QEMU", 4)) {
+			which = 2;
+			classify = 1;
+		} else if (!strncmp(SCpnt->device->model, "ServeRAID", 9)) {
+			which = 3;
+			classify = 1;
+		} else {
+			which = 4;
+			classify = 0;
+		}
+
+		if (!flag[which]) {
+			flag[which] = 1;
+			if (classify) {
+				printk("DSS: ENABLING I/O classification for "
+				       "device \"%s\"\n", SCpnt->device->model);
+			} else {
+				printk("DSS: DISABLING I/O classification for "
+				       "device \"%s\"\n", SCpnt->device->model);
+			}
+		}
+		if (classify) {
+			if (SCpnt->cmnd[0] == WRITE_10 ||
+			    SCpnt->cmnd[0] == READ_10)
+				SCpnt->cmnd[6] = DSS_BIO_CLASS(SCpnt->request->bio);
+		}
+	}
+	/* End DSS.0 */
+
 	ret = BLKPREP_OK;
  out:
 	return scsi_prep_return(q, rq, ret);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/bio.c linux-2.6.32-431.29.2.el6.x86_64/fs/bio.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/bio.c	2014-07-28 03:21:59.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/bio.c	2014-08-29 20:52:51.666000824 +0800
@@ -28,6 +28,7 @@
 #include <scsi/sg.h>		/* for struct sg_iovec */
 
 #include <trace/events/block.h>
+#include <linux/dss_types.h>
 
 /*
  * Test patch to inline a certain number of bi_io_vec's inside the bio
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/buffer.c linux-2.6.32-431.29.2.el6.x86_64/fs/buffer.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/buffer.c	2014-08-29 20:53:46.707000018 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/buffer.c	2014-08-29 20:52:51.667000771 +0800
@@ -41,6 +41,7 @@
 #include <linux/bitops.h>
 #include <linux/mpage.h>
 #include <linux/bit_spinlock.h>
+#include <linux/dss_types.h>
 
 static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 
@@ -916,6 +917,8 @@
 		atomic_set(&bh->b_count, 0);
 		bh->b_private = NULL;
 		bh->b_size = size;
+		/* default classifier */
+		dss_set_bh_class(bh, 0);
 
 		/* Link the buffer to its page */
 		set_bh_page(bh, page, offset);
@@ -1418,6 +1421,18 @@
 }
 EXPORT_SYMBOL(__breadahead);
 
+void __breadahead_dss(struct block_device *bdev, sector_t block, unsigned size,
+		      unsigned char class)
+{
+	struct buffer_head *bh = __getblk(bdev, block, size);
+	if (likely(bh)) {
+		dss_set_bh_class(bh, class);
+		ll_rw_block(READA, 1, &bh);
+		brelse(bh);
+	}
+}
+EXPORT_SYMBOL(__breadahead_dss);
+
 /**
  *  __bread() - reads a specified block and returns the bh
  *  @bdev: the block_device to read from
@@ -1438,6 +1453,20 @@
 }
 EXPORT_SYMBOL(__bread);
 
+struct buffer_head *
+__bread_dss(struct block_device *bdev, sector_t block, unsigned size,
+	    unsigned char class)
+{
+	struct buffer_head *bh = __getblk(bdev, block, size);
+
+	if (likely(bh) && !buffer_uptodate(bh)) {
+		dss_set_bh_class(bh, class);
+		bh = __bread_slow(bh);
+	}
+	return bh;
+}
+EXPORT_SYMBOL(__bread_dss);
+
 /*
  * invalidate_bh_lrus() is called rarely - but not only at unmount.
  * This doesn't race because it runs in each cpu either in irq
@@ -1625,10 +1654,24 @@
 
 static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)
 {
+	struct buffer_head *head, *bh;
+	int class = dss_tag_file_type(page->mapping->host);
+
 	BUG_ON(!PageLocked(page));
 
 	if (!page_has_buffers(page))
 		create_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);
+
+	head = page_buffers(page);
+	bh = head;
+	do {
+		if (bh == NULL)
+			break;
+
+		dss_set_bh_class(bh, class);
+		bh = bh->b_this_page;
+	} while (bh != head);
+
 	return page_buffers(page);
 }
 
@@ -3181,6 +3224,7 @@
 	guard_bh_eod(rw, bio, bh);
 
 	bio_get(bio);
+	dss_set_bio_class(bio, DSS_BH_CLASS(bh));
 	submit_bio(rw, bio);
 
 	if (bio_flagged(bio, BIO_EOPNOTSUPP))
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/direct-io.c linux-2.6.32-431.29.2.el6.x86_64/fs/direct-io.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/direct-io.c	2014-07-28 03:21:52.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/direct-io.c	2014-08-29 20:52:51.668000723 +0800
@@ -35,6 +35,7 @@
 #include <linux/buffer_head.h>
 #include <linux/rwsem.h>
 #include <linux/uio.h>
+#include <linux/dss_types.h>
 #include <asm/atomic.h>
 #include <linux/prefetch.h>
 
@@ -381,6 +382,8 @@
 	if (dio->is_async && dio->rw == READ)
 		bio_set_pages_dirty(bio);
 
+	dss_set_bio_class(bio, DSS_DATA_DIRECT);
+
 	if (sdio->submit_io)
 		sdio->submit_io(dio->rw, bio, dio->inode,
 			       sdio->logical_offset_in_bio);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/balloc.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/balloc.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/balloc.c	2014-07-28 03:22:03.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/balloc.c	2014-08-29 20:52:51.668000723 +0800
@@ -17,6 +17,7 @@
 #include <linux/jbd2.h>
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
+#include <linux/dss_types.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
 #include "mballoc.h"
@@ -309,6 +310,8 @@
 		return NULL;
 	}
 
+	dss_set_bh_class(bh, DSS_BLK_BMP);
+
 	if (bitmap_uptodate(bh))
 		return bh;
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/dir.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/dir.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/dir.c	2014-07-28 03:22:04.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/dir.c	2014-08-29 20:52:51.669000676 +0800
@@ -26,6 +26,7 @@
 #include <linux/buffer_head.h>
 #include <linux/slab.h>
 #include <linux/rbtree.h>
+#include <linux/dss_types.h>
 #include "ext4.h"
 
 static unsigned char ext4_filetype_table[] = {
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/extents.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/extents.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/extents.c	2014-07-28 03:22:03.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/extents.c	2014-08-29 20:52:51.670000634 +0800
@@ -41,6 +41,7 @@
 #include <linux/falloc.h>
 #include <asm/uaccess.h>
 #include <linux/fiemap.h>
+#include <linux/dss_types.h>
 #include "ext4_jbd2.h"
 #include "ext4_extents.h"
 
@@ -721,6 +722,10 @@
 		bh = sb_getblk(inode->i_sb, path[ppos].p_block);
 		if (unlikely(!bh))
 			goto err;
+
+		/* entry point to search extents */
+		dss_set_bh_class(bh, DSS_EXTENT); /*DSS.f extent*/
+
 		if (!bh_uptodate_or_lock(bh)) {
 			if (bh_submit_read(bh) < 0) {
 				put_bh(bh);
@@ -917,6 +922,7 @@
 		err = -EIO;
 		goto cleanup;
 	}
+	dss_set_bh_class(bh, DSS_EXTENT);
 	lock_buffer(bh);
 
 	err = ext4_journal_get_create_access(handle, bh);
@@ -989,6 +995,7 @@
 			err = -EIO;
 			goto cleanup;
 		}
+		dss_set_bh_class(bh, DSS_EXTENT);
 		lock_buffer(bh);
 
 		err = ext4_journal_get_create_access(handle, bh);
@@ -1105,6 +1112,7 @@
 		ext4_std_error(inode->i_sb, err);
 		return err;
 	}
+	dss_set_bh_class(bh, DSS_EXTENT);
 	lock_buffer(bh);
 
 	err = ext4_journal_get_create_access(handle, bh);
@@ -1388,7 +1396,7 @@
 	ix++;
 	block = ext4_idx_pblock(ix);
 	while (++depth < path->p_depth) {
-		bh = sb_bread(inode->i_sb, block);
+		bh = sb_bread_dss(inode->i_sb, block, DSS_EXTENT);
 		if (bh == NULL)
 			return -EIO;
 		eh = ext_block_hdr(bh);
@@ -1403,7 +1411,7 @@
 		put_bh(bh);
 	}
 
-	bh = sb_bread(inode->i_sb, block);
+	bh = sb_bread_dss(inode->i_sb, block, DSS_EXTENT);
 	if (bh == NULL)
 		return -EIO;
 	eh = ext_block_hdr(bh);
@@ -2662,7 +2670,8 @@
 			ext_debug("move to level %d (block %llu)\n",
 				  i + 1, ext4_idx_pblock(path[i].p_idx));
 			memset(path + i + 1, 0, sizeof(*path));
-			bh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));
+			bh = sb_bread_dss(sb, ext4_idx_pblock(path[i].p_idx),
+					  DSS_EXTENT);
 			if (!bh) {
 				/* should we reset i_size? */
 				err = -EIO;
@@ -2786,7 +2795,8 @@
 	ee_len    = ext4_ext_get_actual_len(ex);
 	ee_pblock = ext4_ext_pblock(ex);
 
-	ret = sb_issue_zeroout(inode->i_sb, ee_pblock, ee_len, GFP_NOFS);
+	ret = sb_issue_zeroout_dss(inode->i_sb, ee_pblock, ee_len, GFP_NOFS,
+				   DSS_EXTENT);
 	if (ret > 0)
 		ret = 0;
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/ialloc.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/ialloc.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/ialloc.c	2014-07-28 03:21:55.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/ialloc.c	2014-08-29 20:52:51.671000592 +0800
@@ -22,6 +22,7 @@
 #include <linux/random.h>
 #include <linux/bitops.h>
 #include <linux/blkdev.h>
+#include <linux/dss_types.h>
 #include <asm/byteorder.h>
 
 #include "ext4.h"
@@ -116,6 +117,9 @@
 			    block_group, bitmap_blk);
 		return NULL;
 	}
+
+	dss_set_bh_class(bh, DSS_INO_BMP);
+
 	if (bitmap_uptodate(bh))
 		return bh;
 
@@ -1319,7 +1323,7 @@
 
 	ext4_debug("going to zero out inode table in group %d\n",
 		   group);
-	ret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);
+	ret = sb_issue_zeroout_dss(sb, blk, num, GFP_NOFS, DSS_INODE);
 	if (ret < 0)
 		goto err_out;
 	if (barrier)
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/inode.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/inode.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/inode.c	2014-07-28 03:22:04.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/inode.c	2014-08-29 20:52:51.673000520 +0800
@@ -38,6 +38,7 @@
 #include <linux/uio.h>
 #include <linux/bio.h>
 #include <linux/workqueue.h>
+#include <linux/dss_types.h>
 
 #include "ext4_jbd2.h"
 #include "xattr.h"
@@ -470,6 +471,8 @@
 		if (unlikely(!bh))
 			goto failure;
 
+		dss_set_bh_class(bh, DSS_INDIRECT);
+
 		if (!bh_uptodate_or_lock(bh)) {
 			if (bh_submit_read(bh) < 0) {
 				put_bh(bh);
@@ -801,6 +804,9 @@
 		 * parent to disk.
 		 */
 		bh = sb_getblk(inode->i_sb, new_blocks[n-1]);
+		if (bh)
+			dss_set_bh_class(bh, DSS_INDIRECT);
+
 		branch[n].bh = bh;
 		lock_buffer(bh);
 		BUFFER_TRACE(bh, "call get_create_access");
@@ -1426,6 +1432,7 @@
 	if (ret > 0) {
 		bh_result->b_size = (ret << inode->i_blkbits);
 		ret = 0;
+		dss_bh_tag_file_size(inode, bh_result, iblock);
 	}
 	if (started)
 		ext4_journal_stop(handle);
@@ -1550,6 +1557,9 @@
 	bh = ext4_getblk(handle, inode, block, create, err);
 	if (!bh)
 		return bh;
+
+	dss_set_bh_class(bh, dss_tag_file_type(inode));
+
 	if (buffer_uptodate(bh))
 		return bh;
 	ll_rw_block(READ_META, 1, &bh);
@@ -2821,6 +2831,7 @@
 	loff_t size;
 	unsigned int len;
 	struct buffer_head *page_bufs;
+	struct buffer_head *bh;
 	struct inode *inode = page->mapping->host;
 
 	trace_ext4_writepage(inode, page);
@@ -2832,6 +2843,15 @@
 
 	if (page_has_buffers(page)) {
 		page_bufs = page_buffers(page);
+		bh = page_bufs;
+		do {
+			if (!bh)
+				break;
+
+			dss_bh_tag_file_size(inode, bh, 0);
+			bh = bh->b_this_page;
+		} while (bh != page_bufs);
+
 		if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,
 					ext4_bh_delay_or_unwritten)) {
 			/*
@@ -2868,6 +2888,14 @@
 					  noalloc_get_block_write);
 		if (!ret) {
 			page_bufs = page_buffers(page);
+			bh = page_bufs;
+			do {
+				if (!bh)
+					break;
+				dss_bh_tag_file_size(inode, bh, 0);
+				bh = bh->b_this_page;
+			} while (bh != page_bufs);
+
 			/* check whether all are mapped and non delay */
 			if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,
 						ext4_bh_delay_or_unwritten)) {
@@ -4398,6 +4426,7 @@
 
 		if (!buffer_uptodate(bh)) {
 			err = -EIO;
+			dss_bh_tag_file_size(inode, bh, iblock); /*DSS.f */
 			ll_rw_block(READ, 1, &bh);
 			wait_on_buffer(bh);
 			/* Uhhuh. Read error. Complain and punt.*/
@@ -4531,6 +4560,7 @@
 
 	if (!buffer_uptodate(bh)) {
 		err = -EIO;
+		dss_bh_tag_file_size(inode, bh, iblock); /*DSS.f */
 		ll_rw_block(READ, 1, &bh);
 		wait_on_buffer(bh);
 		/* Uhhuh. Read error. Complain and punt. */
@@ -4839,7 +4869,7 @@
 				continue;		/* A hole */
 
 			/* Go read the buffer for the next level down */
-			bh = sb_bread(inode->i_sb, nr);
+			bh = sb_bread_dss(inode->i_sb, nr, DSS_INDIRECT);
 
 			/*
 			 * A read failure? Report error and clear slot
@@ -5202,6 +5232,7 @@
 			   "inode=%lu, block=%llu", inode->i_ino, block);
 		return -EIO;
 	}
+	dss_set_bh_class(bh, DSS_INODE);
 	if (!buffer_uptodate(bh)) {
 		lock_buffer(bh);
 
@@ -5236,6 +5267,8 @@
 			if (!bitmap_bh)
 				goto make_io;
 
+			dss_set_bh_class(bitmap_bh, DSS_INO_BMP);
+
 			/*
 			 * If the inode bitmap isn't in cache then the
 			 * optimisation may end up performing two reads instead
@@ -5284,7 +5317,7 @@
 			if (end > table)
 				end = table;
 			while (b <= end)
-				sb_breadahead(sb, b++);
+				sb_breadahead_dss(sb, b++, DSS_INODE);
 		}
 
 		/*
@@ -5294,6 +5327,7 @@
 		 */
 		get_bh(bh);
 		bh->b_end_io = end_buffer_read_sync;
+		dss_set_bh_class(bh, DSS_INODE);
 		submit_bh(READ_META, bh);
 		wait_on_buffer(bh);
 		if (!buffer_uptodate(bh)) {
@@ -5305,6 +5339,7 @@
 	}
 has_buffer:
 	iloc->bh = bh;
+	dss_set_bh_class(bh, DSS_INODE);
 	return 0;
 }
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/mballoc.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/mballoc.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/mballoc.c	2014-07-28 03:21:54.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/mballoc.c	2014-08-29 20:52:51.674000487 +0800
@@ -23,6 +23,7 @@
 
 #include "mballoc.h"
 #include <linux/debugfs.h>
+#include <linux/dss_types.h>
 #include <trace/events/ext4.h>
 
 /*
@@ -823,6 +824,8 @@
 		if (bh[i] == NULL)
 			goto out;
 
+		dss_set_bh_class(bh[i], DSS_BLK_BMP);
+
 		if (bitmap_uptodate(bh[i]))
 			continue;
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/migrate.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/migrate.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/migrate.c	2014-07-28 03:21:48.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/migrate.c	2014-08-29 20:52:51.675000456 +0800
@@ -13,6 +13,8 @@
  */
 
 #include <linux/module.h>
+#include <linux/migrate.h>
+#include <linux/dss_types.h>
 #include "ext4_jbd2.h"
 #include "ext4_extents.h"
 
@@ -126,7 +128,7 @@
 		return 0;
 	}
 
-	bh = sb_bread(inode->i_sb, pblock);
+	bh = sb_bread_dss(inode->i_sb, pblock, DSS_EXTENT);
 	if (!bh)
 		return -EIO;
 
@@ -163,7 +165,7 @@
 		*blk_nump += max_entries * max_entries;
 		return 0;
 	}
-	bh = sb_bread(inode->i_sb, pblock);
+	bh = sb_bread_dss(inode->i_sb, pblock, DSS_EXTENT);
 	if (!bh)
 		return -EIO;
 
@@ -203,7 +205,7 @@
 		*blk_nump += max_entries * max_entries * max_entries;
 		return 0;
 	}
-	bh = sb_bread(inode->i_sb, pblock);
+	bh = sb_bread_dss(inode->i_sb, pblock, DSS_EXTENT);
 	if (!bh)
 		return -EIO;
 
@@ -254,7 +256,7 @@
 	struct buffer_head *bh;
 	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
 
-	bh = sb_bread(inode->i_sb, le32_to_cpu(i_data));
+	bh = sb_bread_dss(inode->i_sb, le32_to_cpu(i_data), DSS_INDIRECT);
 	if (!bh)
 		return -EIO;
 
@@ -282,7 +284,7 @@
 	struct buffer_head *bh;
 	unsigned long max_entries = inode->i_sb->s_blocksize >> 2;
 
-	bh = sb_bread(inode->i_sb, le32_to_cpu(i_data));
+	bh = sb_bread_dss(inode->i_sb, le32_to_cpu(i_data), DSS_INDIRECT);
 	if (!bh)
 		return -EIO;
 
@@ -408,7 +410,7 @@
 	struct ext4_extent_header *eh;
 
 	block = ext4_idx_pblock(ix);
-	bh = sb_bread(inode->i_sb, block);
+	bh = sb_bread_dss(inode->i_sb, block, DSS_EXTENT);
 	if (!bh)
 		return -EIO;
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/move_extent.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/move_extent.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/move_extent.c	2014-07-28 03:21:48.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/move_extent.c	2014-08-29 20:52:51.676000427 +0800
@@ -15,6 +15,7 @@
 
 #include <linux/fs.h>
 #include <linux/quotaops.h>
+#include <linux/dss_types.h>
 #include "ext4_jbd2.h"
 #include "ext4_extents.h"
 #include "ext4.h"
@@ -99,7 +100,8 @@
 			if (path[ppos+1].p_bh)
 				brelse(path[ppos+1].p_bh);
 			path[ppos+1].p_bh =
-				sb_bread(inode->i_sb, path[ppos].p_block);
+				sb_bread_dss(inode->i_sb, path[ppos].p_block,
+					     DSS_EXTENT);
 			if (!path[ppos+1].p_bh)
 				return -EIO;
 			path[ppos+1].p_hdr =
@@ -113,8 +115,8 @@
 					ext4_idx_pblock(path[cur_ppos].p_idx);
 				if (path[cur_ppos+1].p_bh)
 					brelse(path[cur_ppos+1].p_bh);
-				path[cur_ppos+1].p_bh = sb_bread(inode->i_sb,
-					path[cur_ppos].p_block);
+				path[cur_ppos+1].p_bh = sb_bread_dss(inode->i_sb,
+					path[cur_ppos].p_block, DSS_EXTENT);
 				if (!path[cur_ppos+1].p_bh)
 					return -EIO;
 				path[cur_ppos+1].p_hdr =
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/namei.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/namei.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/namei.c	2014-07-28 03:21:35.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/namei.c	2014-08-29 20:52:51.676000427 +0800
@@ -34,6 +34,7 @@
 #include <linux/quotaops.h>
 #include <linux/buffer_head.h>
 #include <linux/bio.h>
+#include <linux/dss_types.h>
 #include "ext4.h"
 #include "ext4_jbd2.h"
 
@@ -909,6 +910,8 @@
 				}
 				num++;
 				bh = ext4_getblk(NULL, dir, b++, 0, &err);
+				if (bh)
+					dss_set_bh_class(bh, DSS_DATA_DIR);
 				bh_use[ra_max] = bh;
 				if (bh)
 					ll_rw_block(READ_META, 1, &bh);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/resize.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/resize.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/resize.c	2014-07-28 03:21:54.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/resize.c	2014-08-29 20:52:51.677000400 +0800
@@ -13,6 +13,7 @@
 
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/dss_types.h>
 
 #include "ext4_jbd2.h"
 
@@ -58,7 +59,7 @@
 	else if (free_blocks_count < 0)
 		ext4_warning(sb, "Bad blocks count %u",
 			     input->blocks_count);
-	else if (!(bh = sb_bread(sb, end - 1)))
+	else if (!(bh = sb_bread_dss(sb, end - 1, DSS_UNCLASSIFIED)))
 		ext4_warning(sb, "Cannot read last block (%llu)",
 			     end - 1);
 	else if (outside(input->block_bitmap, start, end))
@@ -191,6 +192,7 @@
 		err = PTR_ERR(bh);
 		goto exit_journal;
 	}
+	dss_set_bh_class(bh, DSS_BLK_BMP);
 
 	if (ext4_bg_has_super(sb, input->group)) {
 		ext4_debug("mark backup superblock %#04llx (+0)\n", start);
@@ -212,6 +214,9 @@
 			err = -EIO;
 			goto exit_bh;
 		}
+
+		dss_set_bh_class(gdb, DSS_GROUP);
+
 		if ((err = ext4_journal_get_write_access(handle, gdb))) {
 			brelse(gdb);
 			goto exit_bh;
@@ -228,8 +233,8 @@
 	/* Zero out all of the reserved backup group descriptor table blocks */
 	ext4_debug("clear inode table blocks %#04llx -> %#04lx\n",
 			block, sbi->s_itb_per_group);
-	err = sb_issue_zeroout(sb, gdblocks + start + 1, reserved_gdb,
-			       GFP_NOFS);
+	err = sb_issue_zeroout_dss(sb, gdblocks + start + 1, reserved_gdb,
+				   GFP_NOFS, DSS_GROUP);
 	if (err)
 		goto exit_bh;
 	for (i = 0, bit = gdblocks + 1; i < reserved_gdb; i++, bit++)
@@ -247,7 +252,8 @@
 	block = input->inode_table;
 	ext4_debug("clear inode table blocks %#04llx -> %#04lx\n",
 			block, sbi->s_itb_per_group);
-	err = sb_issue_zeroout(sb, block, sbi->s_itb_per_group, GFP_NOFS);
+	err = sb_issue_zeroout_dss(sb, block, sbi->s_itb_per_group, GFP_NOFS,
+				   DSS_INODE);
 	if (err)
 		goto exit_bh;
 	for (i = 0, bit = input->inode_table - start;
@@ -257,6 +263,7 @@
 	if ((err = extend_or_restart_transaction(handle, 2, bh)))
 		goto exit_bh;
 
+	dss_set_bh_class(bh, DSS_INO_BMP);
 	mark_bitmap_end(input->blocks_count, sb->s_blocksize * 8, bh->b_data);
 	ext4_handle_dirty_metadata(handle, NULL, bh);
 	brelse(bh);
@@ -398,7 +405,7 @@
 		return -EPERM;
 	}
 
-	*primary = sb_bread(sb, gdblock);
+	*primary = sb_bread_dss(sb, gdblock, DSS_GROUP);
 	if (!*primary)
 		return -EIO;
 
@@ -408,7 +415,7 @@
 	}
 
 	data = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;
-	dind = sb_bread(sb, le32_to_cpu(*data));
+	dind = sb_bread_dss(sb, le32_to_cpu(*data), DSS_INDIRECT);
 	if (!dind) {
 		err = -EIO;
 		goto exit_bh;
@@ -524,7 +531,7 @@
 		return -ENOMEM;
 
 	data = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;
-	dind = sb_bread(sb, le32_to_cpu(*data));
+	dind = sb_bread_dss(sb, le32_to_cpu(*data), DSS_INDIRECT);
 	if (!dind) {
 		err = -EIO;
 		goto exit_free;
@@ -545,7 +552,7 @@
 			err = -EINVAL;
 			goto exit_bh;
 		}
-		primary[res] = sb_bread(sb, blk);
+		primary[res] = sb_bread_dss(sb, blk, DSS_GROUP);
 		if (!primary[res]) {
 			err = -EIO;
 			goto exit_bh;
@@ -655,6 +662,8 @@
 			err = -EIO;
 			break;
 		}
+
+		dss_set_bh_class(bh, DSS_MISC);
 		ext4_debug("update metadata backup %#04lx\n",
 			  (unsigned long)bh->b_blocknr);
 		if ((err = ext4_journal_get_write_access(handle, bh)))
@@ -998,7 +1007,7 @@
 			     o_blocks_count + add, add);
 
 	/* See if the device is actually as big as what was requested */
-	bh = sb_bread(sb, o_blocks_count + add - 1);
+	bh = sb_bread_dss(sb, o_blocks_count + add - 1, DSS_UNCLASSIFIED);
 	if (!bh) {
 		ext4_warning(sb, "can't read last block, resize aborted");
 		return -ENOSPC;
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/super.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/super.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/super.c	2014-07-28 03:22:03.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/super.c	2014-08-29 20:52:51.678000375 +0800
@@ -43,6 +43,7 @@
 
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/dss_types.h>
 
 #include "ext4.h"
 #include "ext4_jbd2.h"
@@ -2948,7 +2949,7 @@
 		logical_sb_block = sb_block;
 	}
 
-	if (!(bh = sb_bread(sb, logical_sb_block))) {
+	if (!(bh = sb_bread_dss(sb, logical_sb_block, DSS_SUPER))) {
 		ext4_msg(sb, KERN_ERR, "unable to read superblock");
 		goto out_fail;
 	}
@@ -3069,7 +3070,7 @@
 		brelse(bh);
 		logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;
 		offset = do_div(logical_sb_block, blocksize);
-		bh = sb_bread(sb, logical_sb_block);
+		bh = sb_bread_dss(sb, logical_sb_block, DSS_SUPER);
 		if (!bh) {
 			ext4_msg(sb, KERN_ERR,
 			       "Can't read superblock on 2nd try");
@@ -3239,7 +3240,7 @@
 
 	for (i = 0; i < db_count; i++) {
 		block = descriptor_loc(sb, logical_sb_block, i);
-		sbi->s_group_desc[i] = sb_bread(sb, block);
+		sbi->s_group_desc[i] = sb_bread_dss(sb, block, DSS_GROUP);
 		if (!sbi->s_group_desc[i]) {
 			ext4_msg(sb, KERN_ERR,
 			       "can't read group descriptor %d", i);
@@ -3537,6 +3538,7 @@
 	ext4_msg(sb, KERN_INFO, "mounted filesystem with%s. "
 		 "Opts: %s%s", descr, sbi->s_es->s_mount_opts,
 		 *sbi->s_es->s_mount_opts ? "; " : "");
+	ext4_msg(sb, KERN_INFO, "DDN SFX Cache hints enabled.\n");
 
 	lock_kernel();
 	return 0;
@@ -3702,7 +3704,7 @@
 	sb_block = EXT4_MIN_BLOCK_SIZE / blocksize;
 	offset = EXT4_MIN_BLOCK_SIZE % blocksize;
 	set_blocksize(bdev, blocksize);
-	if (!(bh = __bread(bdev, sb_block, blocksize))) {
+	if (!(bh = __bread_dss(bdev, sb_block, blocksize, DSS_JOURNAL))) {
 		ext4_msg(sb, KERN_ERR, "couldn't read superblock of "
 		       "external journal");
 		goto out_bdev;
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/xattr.c linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/xattr.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/ext4/xattr.c	2014-07-28 03:21:48.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/ext4/xattr.c	2014-08-29 20:52:51.679000352 +0800
@@ -56,6 +56,7 @@
 #include <linux/mbcache.h>
 #include <linux/quotaops.h>
 #include <linux/rwsem.h>
+#include <linux/dss_types.h>
 #include "ext4_jbd2.h"
 #include "ext4.h"
 #include "xattr.h"
@@ -221,7 +222,7 @@
 	if (!EXT4_I(inode)->i_file_acl)
 		goto cleanup;
 	ea_idebug(inode, "reading block %u", EXT4_I(inode)->i_file_acl);
-	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
+	bh = sb_bread_dss(inode->i_sb, EXT4_I(inode)->i_file_acl, DSS_XATTR);
 	if (!bh)
 		goto cleanup;
 	ea_bdebug(bh, "b_count=%d, refcount=%d",
@@ -363,7 +364,7 @@
 	if (!EXT4_I(inode)->i_file_acl)
 		goto cleanup;
 	ea_idebug(inode, "reading block %u", EXT4_I(inode)->i_file_acl);
-	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
+	bh = sb_bread_dss(inode->i_sb, EXT4_I(inode)->i_file_acl, DSS_XATTR);
 	error = -EIO;
 	if (!bh)
 		goto cleanup;
@@ -655,7 +656,7 @@
 
 	if (EXT4_I(inode)->i_file_acl) {
 		/* The inode already has an extended attribute block. */
-		bs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);
+		bs->bh = sb_bread_dss(sb, EXT4_I(inode)->i_file_acl, DSS_XATTR);
 		error = -EIO;
 		if (!bs->bh)
 			goto cleanup;
@@ -844,6 +845,7 @@
 				error = -EIO;
 				goto cleanup;
 			}
+			dss_set_bh_class(new_bh, DSS_XATTR);
 			lock_buffer(new_bh);
 			error = ext4_journal_get_create_access(handle, new_bh);
 			if (error) {
@@ -1192,7 +1194,7 @@
 	 * EA block can hold new_extra_isize bytes.
 	 */
 	if (EXT4_I(inode)->i_file_acl) {
-		bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
+		bh = sb_bread_dss(inode->i_sb, EXT4_I(inode)->i_file_acl, DSS_XATTR);
 		error = -EIO;
 		if (!bh)
 			goto cleanup;
@@ -1371,7 +1373,7 @@
 
 	if (!EXT4_I(inode)->i_file_acl)
 		goto cleanup;
-	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
+	bh = sb_bread_dss(inode->i_sb, EXT4_I(inode)->i_file_acl, DSS_XATTR);
 	if (!bh) {
 		ext4_error(inode->i_sb, "inode %lu: block %llu read error",
 			   inode->i_ino, EXT4_I(inode)->i_file_acl);
@@ -1421,6 +1423,7 @@
 		ea_bdebug(bh, "out of memory");
 		return;
 	}
+	dss_set_bh_class(bh, DSS_XATTR);
 	error = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, &hash);
 	if (error) {
 		mb_cache_entry_free(ce);
@@ -1503,7 +1506,7 @@
 				goto again;
 			break;
 		}
-		bh = sb_bread(inode->i_sb, ce->e_block);
+		bh = sb_bread_dss(inode->i_sb, ce->e_block, DSS_XATTR);
 		if (!bh) {
 			ext4_error(inode->i_sb,
 				"inode %lu: block %lu read error",
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/commit.c linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/commit.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/commit.c	2014-07-28 03:21:55.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/commit.c	2014-08-29 20:52:51.679000352 +0800
@@ -29,6 +29,7 @@
 #include <linux/bitops.h>
 #include <trace/events/jbd2.h>
 #include <asm/system.h>
+#include <linux/dss_types.h>
 
 /*
  * Default IO end handler for temporary BJ_IO buffer_heads.
@@ -113,6 +114,7 @@
 		return 1;
 
 	bh = jh2bh(descriptor);
+	dss_set_bh_class(bh, DSS_JOURNAL);
 
 	tmp = (struct commit_header *)bh->b_data;
 	tmp->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);
@@ -649,6 +651,7 @@
 				clear_buffer_dirty(bh);
 				set_buffer_uptodate(bh);
 				bh->b_end_io = journal_end_buffer_io_sync;
+				dss_set_bh_class(bh, DSS_JOURNAL);
 				submit_bh(write_op, bh);
 			}
 			cond_resched();
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/journal.c linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/journal.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/journal.c	2014-07-28 03:21:55.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/journal.c	2014-08-29 20:52:51.680000330 +0800
@@ -49,6 +49,7 @@
 #include <asm/uaccess.h>
 #include <asm/page.h>
 #include <asm/system.h>
+#include <linux/dss_types.h>
 
 EXPORT_SYMBOL(jbd2_journal_start);
 EXPORT_SYMBOL(jbd2_journal_restart);
@@ -756,6 +757,9 @@
 	bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
 	if (!bh)
 		return NULL;
+
+	dss_set_bh_class(bh, DSS_JOURNAL);
+
 	lock_buffer(bh);
 	memset(bh->b_data, 0, journal->j_blocksize);
 	set_buffer_uptodate(bh);
@@ -1003,6 +1007,9 @@
 		       __func__);
 		goto out_err;
 	}
+
+	dss_set_bh_class(bh, DSS_JOURNAL);
+
 	journal->j_sb_buffer = bh;
 	journal->j_superblock = (journal_superblock_t *)bh->b_data;
 
@@ -1077,6 +1084,9 @@
 		       __func__);
 		goto out_err;
 	}
+
+	dss_set_bh_class(bh, DSS_JOURNAL);
+
 	journal->j_sb_buffer = bh;
 	journal->j_superblock = (journal_superblock_t *)bh->b_data;
 
@@ -1193,6 +1203,8 @@
 	sb->s_errno    = cpu_to_be32(journal->j_errno);
 	spin_unlock(&journal->j_state_lock);
 
+	dss_set_bh_class(bh, DSS_JOURNAL);
+
 	BUFFER_TRACE(bh, "marking dirty");
 	mark_buffer_dirty(bh);
 	if (wait) {
@@ -1236,6 +1248,7 @@
 	bh = journal->j_sb_buffer;
 
 	J_ASSERT(bh != NULL);
+	dss_set_bh_class(bh, DSS_JOURNAL);
 	if (!buffer_uptodate(bh)) {
 		ll_rw_block(READ, 1, &bh);
 		wait_on_buffer(bh);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/recovery.c linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/recovery.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/recovery.c	2009-12-03 11:51:21.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/recovery.c	2014-08-29 20:52:51.680000330 +0800
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/crc32.h>
 #endif
+#include <linux/dss_types.h>
 
 /*
  * Maintain information about the progress of the recovery job, so that
@@ -103,6 +104,7 @@
 
 		if (!buffer_uptodate(bh) && !buffer_locked(bh)) {
 			bufs[nbufs++] = bh;
+			dss_set_bh_class(bh, DSS_JOURNAL);
 			if (nbufs == MAXBUF) {
 				ll_rw_block(READ, nbufs, bufs);
 				journal_brelse_array(bufs, nbufs);
@@ -155,6 +157,8 @@
 	if (!bh)
 		return -ENOMEM;
 
+	dss_set_bh_class(bh, DSS_JOURNAL);
+
 	if (!buffer_uptodate(bh)) {
 		/* If this is a brand new buffer, start readahead.
                    Otherwise, we assume we are already reading it.  */
@@ -535,6 +539,8 @@
 						goto failed;
 					}
 
+					dss_set_bh_class(nbh, DSS_JOURNAL);
+
 					lock_buffer(nbh);
 					memcpy(nbh->b_data, obh->b_data,
 							journal->j_blocksize);
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/revoke.c linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/revoke.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/jbd2/revoke.c	2014-07-28 03:21:18.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/jbd2/revoke.c	2014-08-29 20:52:51.681000310 +0800
@@ -89,6 +89,7 @@
 #include <linux/bio.h>
 #endif
 #include <linux/log2.h>
+#include <linux/dss_types.h>
 
 static struct kmem_cache *jbd2_revoke_record_cache;
 static struct kmem_cache *jbd2_revoke_table_cache;
@@ -625,6 +626,7 @@
 	set_buffer_jwrite(bh);
 	BUFFER_TRACE(bh, "write");
 	set_buffer_dirty(bh);
+	dss_set_bh_class(bh, DSS_JOURNAL);
 	write_dirty_buffer(bh, write_op);
 }
 #endif
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/fs/mpage.c linux-2.6.32-431.29.2.el6.x86_64/fs/mpage.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/fs/mpage.c	2014-07-28 03:21:19.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/fs/mpage.c	2014-08-29 20:52:51.681000310 +0800
@@ -26,6 +26,7 @@
 #include <linux/writeback.h>
 #include <linux/backing-dev.h>
 #include <linux/pagevec.h>
+#include <linux/dss_types.h>
 
 /*
  * I/O completion handler for multipage BIOs.
@@ -183,6 +184,7 @@
 	int fully_mapped = 1;
 	unsigned nblocks;
 	unsigned relative_block;
+	int class = dss_tag_file_type(inode);
 
 	if (page_has_buffers(page))
 		goto confused;
@@ -222,6 +224,7 @@
 	 * Then do more get_blocks calls until we are done with this page.
 	 */
 	map_bh->b_page = page;
+	dss_set_bh_class(map_bh, class);
 	while (page_block < blocks_per_page) {
 		map_bh->b_state = 0;
 		map_bh->b_size = 0;
@@ -230,6 +233,7 @@
 			map_bh->b_size = (last_block-block_in_file) << blkbits;
 			if (get_block(inode, block_in_file, map_bh, 0))
 				goto confused;
+
 			*first_logical_block = block_in_file;
 		}
 
@@ -287,8 +291,11 @@
 	/*
 	 * This page will go to BIO.  Do we need to send this BIO off first?
 	 */
-	if (bio && (*last_block_in_bio != blocks[0] - 1))
+	if (bio && (*last_block_in_bio != blocks[0] - 1)) {
+		if (bio)
+			dss_set_bio_class(bio, class);
 		bio = mpage_bio_submit(READ, bio);
+	}
 
 alloc_new:
 	if (bio == NULL) {
@@ -301,17 +308,27 @@
 
 	length = first_hole << blkbits;
 	if (bio_add_page(bio, page, length, 0) < length) {
+		if (bio)
+			dss_set_bio_class(bio, class);
 		bio = mpage_bio_submit(READ, bio);
 		goto alloc_new;
+	} else {
+		if (bio)
+			dss_set_bio_class(bio, class);
 	}
 
 	relative_block = block_in_file - *first_logical_block;
 	nblocks = map_bh->b_size >> blkbits;
 	if ((buffer_boundary(map_bh) && relative_block == nblocks) ||
-	    (first_hole != blocks_per_page))
+	    (first_hole != blocks_per_page)) {
+		if (bio)
+			dss_set_bio_class(bio, class);
 		bio = mpage_bio_submit(READ, bio);
-	else
+	} else {
+		if (bio)
+			dss_set_bio_class(bio, class);
 		*last_block_in_bio = blocks[blocks_per_page - 1];
+	}
 out:
 	return bio;
 
@@ -469,11 +486,14 @@
 	struct buffer_head map_bh;
 	loff_t i_size = i_size_read(inode);
 	int ret = 0;
+	unsigned char class;
 
 	if (page_has_buffers(page)) {
 		struct buffer_head *head = page_buffers(page);
 		struct buffer_head *bh = head;
 
+		class = DSS_BH_CLASS(bh);
+
 		/* If they're all mapped and dirty, do it */
 		page_block = 0;
 		do {
@@ -554,6 +574,7 @@
 	BUG_ON(page_block == 0);
 
 	first_unmapped = page_block;
+	class = DSS_BH_CLASS((&map_bh));
 
 page_is_mapped:
 	end_index = i_size >> PAGE_CACHE_SHIFT;
@@ -576,8 +597,10 @@
 	/*
 	 * This page will go to BIO.  Do we need to send this BIO off first?
 	 */
-	if (bio && mpd->last_block_in_bio != blocks[0] - 1)
+	if (bio && mpd->last_block_in_bio != blocks[0] - 1) {
+		dss_set_bio_class(bio, class);
 		bio = mpage_bio_submit(WRITE, bio);
+	}
 
 alloc_new:
 	if (bio == NULL) {
@@ -587,6 +610,8 @@
 			goto confused;
 	}
 
+	dss_set_bio_class(bio, class);
+
 	/*
 	 * Must try to add the page before marking the buffer clean or
 	 * the confused fail path above (OOM) will be very confused when
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/blkdev.h linux-2.6.32-431.29.2.el6.x86_64/include/linux/blkdev.h
--- linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/blkdev.h	2014-08-29 20:53:46.699000019 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/include/linux/blkdev.h	2014-08-29 20:52:51.682000291 +0800
@@ -1048,6 +1048,19 @@
 				    gfp_mask);
 }
 
+/* Begin DSS */
+extern int blkdev_issue_zeroout_dss(struct block_device *bdev, sector_t sector,
+		sector_t nr_sects, gfp_t gfp_mask, unsigned char class);
+static inline int sb_issue_zeroout_dss(struct super_block *sb, sector_t block,
+		sector_t nr_blocks, gfp_t gfp_mask,unsigned char class)
+{
+	return blkdev_issue_zeroout_dss(sb->s_bdev,
+				    block << (sb->s_blocksize_bits - 9),
+				    nr_blocks << (sb->s_blocksize_bits - 9),
+				    gfp_mask, class);
+}
+/* End DSS */
+
 extern int blk_verify_command(struct request_queue *q,
 			      unsigned char *cmd, fmode_t has_write_perm);
 
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/buffer_head.h linux-2.6.32-431.29.2.el6.x86_64/include/linux/buffer_head.h
--- linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/buffer_head.h	2014-07-28 03:21:49.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/include/linux/buffer_head.h	2014-08-29 20:52:51.682000291 +0800
@@ -192,6 +192,22 @@
 int bh_submit_read(struct buffer_head *bh);
 
 extern int buffer_heads_over_limit;
+/* Begin DSS */
+void __breadahead_dss(struct block_device *, sector_t block, unsigned int size,
+		      unsigned char class);
+struct buffer_head *__bread_dss(struct block_device *, sector_t block,
+				unsigned size, unsigned char class);
+static inline struct buffer_head *
+sb_bread_dss(struct super_block *sb, sector_t block, unsigned char class)
+{
+	return __bread_dss(sb->s_bdev, block, sb->s_blocksize, class);
+}
+static inline void
+sb_breadahead_dss(struct super_block *sb, sector_t block, unsigned char class)
+{
+	 __breadahead_dss(sb->s_bdev, block, sb->s_blocksize, class);
+}
+/* End DSS */
 
 /*
  * Generic address_space_operations implementations for buffer_head-backed
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/dss_types.h linux-2.6.32-431.29.2.el6.x86_64/include/linux/dss_types.h
--- linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/dss_types.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/include/linux/dss_types.h	2014-08-29 20:52:51.682000291 +0800
@@ -0,0 +1,172 @@
+/*
+ * Differentiated Storage Services  definitions
+ * Copyright (C) 2010-2014, Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Frankin St - Fifth Floor, Boston, MA 02110-1301
+*/
+
+
+/* DSS classes for Ext4 */
+
+#ifndef _DSS_TYPES_H_
+#define _DSS_TYPES_H_
+
+#include <linux/buffer_head.h>
+#include <linux/bio.h>
+
+enum {
+	DSS_UNCLASSIFIED = 0,
+	DSS_SUPER = 1,
+	DSS_GROUP = 2,
+	DSS_BLK_BMP = 3,
+	DSS_INO_BMP = 4,
+	DSS_INODE = 5,
+	DSS_INDIRECT = 6,
+	DSS_DATA_DIR = 7,
+	DSS_JOURNAL = 8,
+	DSS_EXTENT = 9,
+	DSS_XATTR = 10,
+	DSS_DATA_FILE_4KB = 11,
+	DSS_DATA_FILE_16KB = 12,
+	DSS_DATA_FILE_64KB = 13,
+	DSS_DATA_FILE_256KB = 14,
+	DSS_DATA_FILE_1MB = 15,
+	DSS_DATA_FILE_4MB = 16,
+	DSS_DATA_FILE_16MB = 17,
+	DSS_DATA_FILE_64MB = 18,
+	DSS_DATA_FILE_256MB = 19,
+	DSS_DATA_FILE_1GB = 20,
+	DSS_DATA_FILE_BULK = 21,
+	DSS_DATA_DIRECT = 22,
+	DSS_MISC = 23
+};
+
+#define IS_DSS_USER(TAG)	((TAG) > DSS_MISC)
+
+#define DSS_CLASS_BITS		8
+#define DSS_CLASS_MASK		((1 << DSS_CLASS_BITS) - 1)
+
+#define DSS_BH_CLASS_OFFSET	(BITS_PER_LONG - 8)
+#define DSS_BIO_CLASS_OFFSET	(BITS_PER_LONG - 16)
+
+#define DSS_BH_CLASS(bh) \
+		(((bh)->b_state >> DSS_BH_CLASS_OFFSET) & DSS_CLASS_MASK)
+static inline void dss_set_bh_class(struct buffer_head *bh, int tag)
+{
+	int i;
+	for (i = 0; i < DSS_CLASS_BITS; i++) {
+		if (tag & (1 << i))
+			set_bit(DSS_BH_CLASS_OFFSET + i, &(bh)->b_state);
+		else
+			clear_bit(DSS_BH_CLASS_OFFSET + i, &(bh)->b_state);
+	}
+}
+
+#define DSS_BIO_CLASS(bio) \
+		 (((bio)->bi_flags >> DSS_BIO_CLASS_OFFSET) & DSS_CLASS_MASK)
+static inline void dss_set_bio_class(struct bio *bio, int tag)
+{
+	int i;
+	for (i = 0; i < DSS_CLASS_BITS; i++) {
+		if (tag & (1 << i))
+			set_bit(DSS_BIO_CLASS_OFFSET + i, &(bio)->bi_flags);
+		else
+			clear_bit(DSS_BIO_CLASS_OFFSET + i, &(bio)->bi_flags);
+	}
+}
+
+/*DSS: tagging according to file sizes */
+static int inline _dss_file_size_tag(struct inode* inode)
+{
+	int tag = DSS_MISC;
+
+	/* DSS.4 (note that inode 8 (the journal) passes through here) */
+	if (S_ISREG(inode->i_mode)) {
+		/* file size classification */
+		uint64_t size = inode->i_size;
+
+		if (size <= 4096) {
+			tag = DSS_DATA_FILE_4KB;
+		} else if (size <= 16384) {
+			tag = DSS_DATA_FILE_16KB;
+		} else if (size <= 65536) {
+			tag = DSS_DATA_FILE_64KB;
+		} else if (size <= 262144) {
+			tag = DSS_DATA_FILE_256KB;
+		} else if (size <= 1048576) {
+			tag = DSS_DATA_FILE_1MB;
+		} else if (size <= 4* 1048576) {
+			tag = DSS_DATA_FILE_4MB;
+		} else if (size <= 16* 1048576) {
+			tag = DSS_DATA_FILE_16MB;
+		} else if (size <= 64* 1048576) {
+			tag = DSS_DATA_FILE_64MB;
+		} else if (size <= 256* 1048576) {
+			tag = DSS_DATA_FILE_256MB;
+		} else if (size <= 1024* 1048576) {
+			tag = DSS_DATA_FILE_1GB;
+		} else {
+			tag = DSS_DATA_FILE_BULK;
+		}
+	} else if (S_ISDIR(inode->i_mode)) {
+		tag = DSS_DATA_DIR;
+	} else {
+		tag = DSS_MISC;
+	}
+
+	return tag;
+}
+
+static int inline dss_bh_tag_file_size(struct inode* inode,
+					struct buffer_head* bh, sector_t iblock)
+{
+	int tag = DSS_MISC;
+
+	/* NOTE: if the bh carries a USER tag, don't override it */
+	if (bh != NULL && IS_DSS_USER(DSS_BH_CLASS(bh)))
+		return DSS_BH_CLASS(bh);
+
+	tag = _dss_file_size_tag(inode);
+
+	if (bh != NULL)
+		dss_set_bh_class(bh, tag);
+
+	return tag;
+}
+
+static int inline dss_bio_tag_file_size(struct inode* inode, struct bio *bio)
+{
+       int tag = _dss_file_size_tag(inode);
+	if (bio != NULL)
+	    dss_set_bio_class(bio, tag);
+	return tag;
+}
+
+static int inline dss_tag_file_type(struct inode *inode)
+{
+	int tag = DSS_MISC;
+
+	if (inode == NULL)
+		return tag;
+
+	if (S_ISREG(inode->i_mode)) {
+		tag = dss_bh_tag_file_size(inode, NULL, 0);
+	} else if (S_ISDIR(inode->i_mode)) {
+		tag = DSS_DATA_DIR;
+	}
+
+	return tag;
+}
+
+#endif /* _DSS_TYPES_H_ */
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/mpage.h linux-2.6.32-431.29.2.el6.x86_64/include/linux/mpage.h
--- linux-2.6.32-431.29.2.el6.x86_64.orig/include/linux/mpage.h	2009-12-03 11:51:21.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/include/linux/mpage.h	2014-08-29 20:52:51.682000291 +0800
@@ -20,5 +20,8 @@
 		struct writeback_control *wbc, get_block_t get_block);
 int mpage_writepage(struct page *page, get_block_t *get_block,
 		struct writeback_control *wbc);
+int mpage_readpages_dss(struct address_space *mapping, struct list_head *pages,
+			unsigned nr_pages, get_block_t get_block, unsigned char class);
+int mpage_readpage_dss(struct page *page, get_block_t get_block, unsigned char class);
 
 #endif
diff -Naur linux-2.6.32-431.29.2.el6.x86_64.orig/mm/bounce.c linux-2.6.32-431.29.2.el6.x86_64/mm/bounce.c
--- linux-2.6.32-431.29.2.el6.x86_64.orig/mm/bounce.c	2014-07-28 03:21:55.000000000 +0800
+++ linux-2.6.32-431.29.2.el6.x86_64/mm/bounce.c	2014-08-29 20:52:51.683000278 +0800
@@ -13,6 +13,7 @@
 #include <linux/init.h>
 #include <linux/hash.h>
 #include <linux/highmem.h>
+#include <linux/dss_types.h>
 #include <asm/tlbflush.h>
 
 #include <trace/events/block.h>
@@ -288,6 +289,7 @@
 	bio->bi_vcnt = (*bio_orig)->bi_vcnt;
 	bio->bi_idx = (*bio_orig)->bi_idx;
 	bio->bi_size = (*bio_orig)->bi_size;
+	dss_set_bio_class(bio, DSS_BIO_CLASS((*bio_orig))); /* DSS */
 
 	if (pool == page_pool) {
 		bio->bi_end_io = bounce_end_io_write;
